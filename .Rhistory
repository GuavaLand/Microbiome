#mask <- expand.grid(repeatBinaryNTimes)
#When N is 50, the mask is too large
#Generate random boolean mask of 100 x N
##############
#Implementation without checking duplicate observations
##############
#mask <- as.data.frame(matrix(sample(c(0,1),N*300, replace = TRUE), ncol = N))
##############
#Implementation checking duplicate observations (slow!)
##############
##First row of mask:
#mask <- as.data.frame(matrix(sample(c(0,1),50, replace = TRUE), ncol = 50))
#for (row in 2:100) {
#  tempNextRow <-  sample(c(0,1),50, replace = TRUE)
#  #Assume this has not appeared before
#  appeared <- FALSE
#  #Run through 1:row-1 to check if appeared. If yes, generate a new one and do again
#  while (TRUE) {
#    for (subrow in 1:(row-1)) {
#      if (all(mask[subrow,] == tempNextRow)) {
#        appeared <- TRUE
#        break
#      }
#    }
#    if (appeared == FALSE) {
#      #Break out of while loop
#      break
#    }
#    tempNextRow <-  sample(c(0,1),50, replace = TRUE)
#  }
#  mask[row,] <- tempNextRow
#}
#Loop through 2^N(or 300) to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
#SSMatrix <- as.data.frame(matrix(nrow = 300, ncol = N))
#colnm <- c(1:N)
#colnames(SSMatrix) <- colnm
#for (i in 1:300) {
#  init <- init.x*mask[i,]
#  init <- as.numeric(init)
#  dat <- n.integrate(0:100, init, glv, list(alpha=alpha, c0=c0, l=l))
#  SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
#}
#################################
#Find the components of the rate
#Input simulated density over time, species ID as column; alpha, c0, l
#Outpu matrices of broken down growth rate
#################################
findRateComponent <- function(dat, alpha, c0, l){
#Create local variable to store input
dat = dat
alpha = alpha
c0 = c0
l = l
#Plot dat
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Modified GLV-density', N,'species'))
dat_density <- dat[,2:ncol(dat)]
#First term of growth rate: multiply alpha to x
term1 <- apply(dat_density,1,function(x) alpha*x)
term1 <- as.data.frame(t(term1))
colnames(term1) <- paste('species', 1:N, sep='')
term1$time <- dat$time
term1$term <- factor(rep(1,nrow(term1)))
#Second term of growth rate
term2 <- apply(dat_density,1,function(x) x*as.vector(c0%*%x))
term2 <- as.data.frame(t(term2))
colnames(term2) <- paste('species', 1:N, sep='')
term2$time <- dat$time
term2$term <- factor(rep(2,nrow(term2)))
#Third term of growth rate
term3 <- apply(dat_density,1,function(x) x*t(t(x)%*%(do.call(cbind, lapply(l, FUN=function(ma) ma%*%x)))))
term3 <- as.data.frame(t(term3))
colnames(term3) <- paste('species', 1:N, sep='')
term3$time <- dat$time
term3$term <- factor(rep(3,nrow(term3)))
returnList <- list(term1, term2, term3)
return(returnList)
}
library(ggplot2)
###############################################################
#This function receives three rate components (separate matrices) of all species (column) over time (row)
#and plot rate component over time for each species (N plots)
###############################################################
plotRateComponent <- function(term1, term2, term3){
#number of species
N = ncol(term1) - 2
#total rate
rate = term1[,1:N] + term2[,1:N] + term3[,1:N]
rate$time = term1$time
#Iterate through all species
for (n in 1:N) {
print(ggplot(term1,aes_string(x = 'time',y = paste('species',n,sep='')))+
geom_area(aes(fill = term),alpha=0.5) + geom_area(data=term2,aes(fill = term),alpha=0.5)+
geom_area(data = term3,aes(fill = term),alpha = 0.5)+
geom_line(data = rate)) #superimpose with overall growth rate
}
}
kk = growthFunction(10)
kk
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*as.vector(c0%*%x)+x*t(t(x)%*%(do.call(cbind, lapply(l, FUN=function(ma) ma%*%x))))
list(dx)
})
}
#glv1 as original GLV
#c0 is beta
glv1 <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*as.vector(c0%*%x)
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
#N <- 30
growthFunction <- function(N){
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck <- runif(N*N, min = -1, max = 0.2)
ck <- matrix(ck, nrow = N)
l <- list()
for (i in 1:N) {
#For i-th matrix, i-th row is 0
temp <- ck
temp[i,] <- 0
#In i-th matrix, elements are 0 if k (column) == either j (row) or i (matrix order)
for (j in 1:N) {
for (k in 1:N) {
if (k==j | k == i) {
temp[j,k] <- 0
}
}
}
#Control the prevalence of thrid party effects
#for (element in 1:length(temp)) {
#  dice <- runif(1)
#  if (dice > -1) { #what percent of to assign 0
#    temp[element] <- 0
#  }
#}
l[[i]] <- temp
}
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:500, init.x, glv, list(alpha=alpha, c0=c0, l=l))
dat1 <- n.integrate(0:500, init.x, glv1, list(alpha=alpha, c0=c0))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Modified GLV-density', N,'species'))
matplot(x=dat1$time, y=dat1[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Original GLV-density', N,'species'))
returnList <- list(dat = dat,dat1 = dat1, alpha = alpha, c0 = c0, l = l)
return(returnList)
}
###############################################################################
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
#repeatBinaryNTimes <- rep(list(c(0,1)),N)
#mask <- expand.grid(repeatBinaryNTimes)
#When N is 50, the mask is too large
#Generate random boolean mask of 100 x N
##############
#Implementation without checking duplicate observations
##############
#mask <- as.data.frame(matrix(sample(c(0,1),N*300, replace = TRUE), ncol = N))
##############
#Implementation checking duplicate observations (slow!)
##############
##First row of mask:
#mask <- as.data.frame(matrix(sample(c(0,1),50, replace = TRUE), ncol = 50))
#for (row in 2:100) {
#  tempNextRow <-  sample(c(0,1),50, replace = TRUE)
#  #Assume this has not appeared before
#  appeared <- FALSE
#  #Run through 1:row-1 to check if appeared. If yes, generate a new one and do again
#  while (TRUE) {
#    for (subrow in 1:(row-1)) {
#      if (all(mask[subrow,] == tempNextRow)) {
#        appeared <- TRUE
#        break
#      }
#    }
#    if (appeared == FALSE) {
#      #Break out of while loop
#      break
#    }
#    tempNextRow <-  sample(c(0,1),50, replace = TRUE)
#  }
#  mask[row,] <- tempNextRow
#}
#Loop through 2^N(or 300) to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
#SSMatrix <- as.data.frame(matrix(nrow = 300, ncol = N))
#colnm <- c(1:N)
#colnames(SSMatrix) <- colnm
#for (i in 1:300) {
#  init <- init.x*mask[i,]
#  init <- as.numeric(init)
#  dat <- n.integrate(0:100, init, glv, list(alpha=alpha, c0=c0, l=l))
#  SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
#}
kk = growthFunction(10)
kk
kk[[alpha]]
kk[['alpha']]
rc = findRateComponent(kk[['dat']],kk[['alpha']],kk[['c0']],kk[['l']])
kk[['dat']]
head(kk[['dat']])
#################################
#Find the components of the rate
#Input simulated density over time, species ID as column; alpha, c0, l
#Outpu matrices of broken down growth rate
#################################
findRateComponent <- function(dat, alpha, c0, l){
#Create local variable to store input
dat = dat
alpha = alpha
c0 = c0
l = l
N = ncol(dat) - 1
#Plot dat
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Modified GLV-density', N,'species'))
dat_density <- dat[,2:ncol(dat)]
#First term of growth rate: multiply alpha to x
term1 <- apply(dat_density,1,function(x) alpha*x)
term1 <- as.data.frame(t(term1))
colnames(term1) <- paste('species', 1:N, sep='')
term1$time <- dat$time
term1$term <- factor(rep(1,nrow(term1)))
#Second term of growth rate
term2 <- apply(dat_density,1,function(x) x*as.vector(c0%*%x))
term2 <- as.data.frame(t(term2))
colnames(term2) <- paste('species', 1:N, sep='')
term2$time <- dat$time
term2$term <- factor(rep(2,nrow(term2)))
#Third term of growth rate
term3 <- apply(dat_density,1,function(x) x*t(t(x)%*%(do.call(cbind, lapply(l, FUN=function(ma) ma%*%x)))))
term3 <- as.data.frame(t(term3))
colnames(term3) <- paste('species', 1:N, sep='')
term3$time <- dat$time
term3$term <- factor(rep(3,nrow(term3)))
returnList <- list(term1, term2, term3)
return(returnList)
}
rc = findRateComponent(kk[['dat']],kk[['alpha']],kk[['c0']],kk[['l']])
#################################
#Find the components of the rate
#Input simulated density over time, species ID as column; alpha, c0, l
#Outpu matrices of broken down growth rate
#################################
findRateComponent <- function(dat, alpha, c0, l){
#Create local variable to store input
dat = dat
alpha = alpha
c0 = c0
l = l
N = ncol(dat) - 1
#Plot dat
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Modified GLV-density', N,'species'))
dat_density <- dat[,2:ncol(dat)]
#First term of growth rate: multiply alpha to x
term1 <- apply(dat_density,1,function(x) alpha*x)
term1 <- as.data.frame(t(term1))
colnames(term1) <- paste('species', 1:N, sep='')
term1$time <- dat$time
term1$term <- factor(rep(1,nrow(term1)))
#Second term of growth rate
term2 <- apply(dat_density,1,function(x) x*as.vector(c0%*%x))
term2 <- as.data.frame(t(term2))
colnames(term2) <- paste('species', 1:N, sep='')
term2$time <- dat$time
term2$term <- factor(rep(2,nrow(term2)))
#Third term of growth rate
term3 <- apply(dat_density,1,function(x) x*t(t(x)%*%(do.call(cbind, lapply(l, FUN=function(ma) ma%*%x)))))
term3 <- as.data.frame(t(term3))
colnames(term3) <- paste('species', 1:N, sep='')
term3$time <- dat$time
term3$term <- factor(rep(3,nrow(term3)))
returnList <- list(term1 = term1, term2 = term2, term3 = term3)
return(returnList)
}
kk[['dat']]
plotRateComponent(rc[['term1']],rc[['term2']],rc[['term3']])
head(rc[[term1]])
head(rc[['term1']])
head(rc)
#################################
#Find the components of the rate
#Input simulated density over time, species ID as column; alpha, c0, l
#Outpu matrices of broken down growth rate
#################################
findRateComponent <- function(dat, alpha, c0, l){
#Create local variable to store input
dat = dat
alpha = alpha
c0 = c0
l = l
N = ncol(dat) - 1
#Plot dat
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Modified GLV-density', N,'species'))
dat_density <- dat[,2:ncol(dat)]
#First term of growth rate: multiply alpha to x
term1 <- apply(dat_density,1,function(x) alpha*x)
term1 <- as.data.frame(t(term1))
colnames(term1) <- paste('species', 1:N, sep='')
term1$time <- dat$time
term1$term <- factor(rep(1,nrow(term1)))
#Second term of growth rate
term2 <- apply(dat_density,1,function(x) x*as.vector(c0%*%x))
term2 <- as.data.frame(t(term2))
colnames(term2) <- paste('species', 1:N, sep='')
term2$time <- dat$time
term2$term <- factor(rep(2,nrow(term2)))
#Third term of growth rate
term3 <- apply(dat_density,1,function(x) x*t(t(x)%*%(do.call(cbind, lapply(l, FUN=function(ma) ma%*%x)))))
term3 <- as.data.frame(t(term3))
colnames(term3) <- paste('species', 1:N, sep='')
term3$time <- dat$time
term3$term <- factor(rep(3,nrow(term3)))
returnList <- list(term1 = term1, term2 = term2, term3 = term3)
return(returnList)
}
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*as.vector(c0%*%x)+x*t(t(x)%*%(do.call(cbind, lapply(l, FUN=function(ma) ma%*%x))))
list(dx)
})
}
#glv1 as original GLV
#c0 is beta
glv1 <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*as.vector(c0%*%x)
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
#N <- 30
growthFunction <- function(N){
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck <- runif(N*N, min = -1, max = 0.2)
ck <- matrix(ck, nrow = N)
l <- list()
for (i in 1:N) {
#For i-th matrix, i-th row is 0
temp <- ck
temp[i,] <- 0
#In i-th matrix, elements are 0 if k (column) == either j (row) or i (matrix order)
for (j in 1:N) {
for (k in 1:N) {
if (k==j | k == i) {
temp[j,k] <- 0
}
}
}
#Control the prevalence of thrid party effects
#for (element in 1:length(temp)) {
#  dice <- runif(1)
#  if (dice > -1) { #what percent of to assign 0
#    temp[element] <- 0
#  }
#}
l[[i]] <- temp
}
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:500, init.x, glv, list(alpha=alpha, c0=c0, l=l))
dat1 <- n.integrate(0:500, init.x, glv1, list(alpha=alpha, c0=c0))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Modified GLV-density', N,'species'))
matplot(x=dat1$time, y=dat1[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Original GLV-density', N,'species'))
returnList <- list(dat = dat,dat1 = dat1, alpha = alpha, c0 = c0, l = l)
return(returnList)
}
###############################################################################
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
#repeatBinaryNTimes <- rep(list(c(0,1)),N)
#mask <- expand.grid(repeatBinaryNTimes)
#When N is 50, the mask is too large
#Generate random boolean mask of 100 x N
##############
#Implementation without checking duplicate observations
##############
#mask <- as.data.frame(matrix(sample(c(0,1),N*300, replace = TRUE), ncol = N))
##############
#Implementation checking duplicate observations (slow!)
##############
##First row of mask:
#mask <- as.data.frame(matrix(sample(c(0,1),50, replace = TRUE), ncol = 50))
#for (row in 2:100) {
#  tempNextRow <-  sample(c(0,1),50, replace = TRUE)
#  #Assume this has not appeared before
#  appeared <- FALSE
#  #Run through 1:row-1 to check if appeared. If yes, generate a new one and do again
#  while (TRUE) {
#    for (subrow in 1:(row-1)) {
#      if (all(mask[subrow,] == tempNextRow)) {
#        appeared <- TRUE
#        break
#      }
#    }
#    if (appeared == FALSE) {
#      #Break out of while loop
#      break
#    }
#    tempNextRow <-  sample(c(0,1),50, replace = TRUE)
#  }
#  mask[row,] <- tempNextRow
#}
#Loop through 2^N(or 300) to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
#SSMatrix <- as.data.frame(matrix(nrow = 300, ncol = N))
#colnm <- c(1:N)
#colnames(SSMatrix) <- colnm
#for (i in 1:300) {
#  init <- init.x*mask[i,]
#  init <- as.numeric(init)
#  dat <- n.integrate(0:100, init, glv, list(alpha=alpha, c0=c0, l=l))
#  SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
#}
kk = growthFunction(10)
rc = findRateComponent(kk[['dat']],kk[['alpha']],kk[['c0']],kk[['l']])
head(rc)
plotRateComponent(rc[['term1']],rc[['term2']],rc[['term3']])
rc[['term1']]
library(ggplot2)
###############################################################
#This function receives three rate components (separate matrices) of all species (column) over time (row)
#and plot rate component over time for each species (N plots)
###############################################################
plotRateComponent <- function(term1, term2, term3){
########################################
#cus term3 dies out quickly, if want to look at only the beginning, run the following section
term1 <- term1[1:30,]
term2 <- term2[1:30,]
term3 <- term3[1:30,]
##########################################
#number of species
N = ncol(term1) - 2
#total rate
rate = term1[,1:N] + term2[,1:N] + term3[,1:N]
rate$time = term1$time
#Iterate through all species
for (n in 1:N) {
print(ggplot(term1,aes_string(x = 'time',y = paste('species',n,sep='')))+
geom_area(aes(fill = term),alpha=0.5) + geom_area(data=term2,aes(fill = term),alpha=0.5)+
geom_area(data = term3,aes(fill = term),alpha = 0.5)+
geom_line(data = rate)) #superimpose with overall growth rate
}
}
plotRateComponent(rc[['term1']],rc[['term2']],rc[['term3']])
library(ggplot2)
###############################################################
#This function receives three rate components (separate matrices) of all species (column) over time (row)
#and plot rate component over time for each species (N plots)
###############################################################
plotRateComponent <- function(term1, term2, term3){
########################################
#cus term3 dies out quickly, if want to look at only the beginning, run the following section
term1 <- term1[1:60,] #look at rate from begining to 60 second
term2 <- term2[1:60,]
term3 <- term3[1:60,]
##########################################
#number of species
N = ncol(term1) - 2
#total rate
rate = term1[,1:N] + term2[,1:N] + term3[,1:N]
rate$time = term1$time
#Iterate through all species
for (n in 1:N) {
print(ggplot(term1,aes_string(x = 'time',y = paste('species',n,sep='')))+
geom_area(aes(fill = term),alpha=0.5) + geom_area(data=term2,aes(fill = term),alpha=0.5)+
geom_area(data = term3,aes(fill = term),alpha = 0.5)+
geom_line(data = rate)) #superimpose with overall growth rate
}
}
plotRateComponent(rc[['term1']],rc[['term2']],rc[['term3']])
