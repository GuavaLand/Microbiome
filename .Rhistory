c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Uncomment to execute the following section
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <-  rep(0,N)
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
rbind(SSMatrix,dat[nrow(dat),])
}
SSMatrix <- SSMatrix[-1,]
tail(SSMatrix)
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*(c0%*%x)+x*((ck1%*%x)%*%(ck2%*%x))
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
N <- 10
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Uncomment to execute the following section
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <-  rep(0,N)
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
rbind(SSMatrix,dat[nrow(dat),])
}
SSMatrix <- SSMatrix[-1,]
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*(c0%*%x)+x*((ck1%*%x)%*%(ck2%*%x))
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
N <- 10
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Uncomment to execute the following section
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- matrix(nrow = 2^N, ncol = N)
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- dat[nrow(out),2:(N+1)]
}
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*(c0%*%x)+x*((ck1%*%x)%*%(ck2%*%x))
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
N <- 10
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Uncomment to execute the following section
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- matrix(nrow = 2^N, ncol = N)
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
}
tail(dat)
nrow(dat)
dat[nrow(dat),2:(N+1)]
i
tail(SSMatrix)
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*(c0%*%x)+x*((ck1%*%x)%*%(ck2%*%x))
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
N <- 10
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Uncomment to execute the following section
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- matrix(nrow = 2^N, ncol = N)
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
}
SSMatrix
SSMatrix <- matrix(rep(0,N*2^N),nrow = 2^N, ncol = N)
head(SSMatrix)
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*(c0%*%x)+x*((ck1%*%x)%*%(ck2%*%x))
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
N <- 10
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Uncomment to execute the following section
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- matrix(rep(0,N*2^N),nrow = 2^N, ncol = N)
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
}
SSMatrix
head(mask)
init.x
init <- init.x*mask[1,]
init <- as.numeric(init)
init
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
tail(dat)
SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
dat[nrow(dat),2:(N+1)]
data.frame(rep(0,N*2^N),nrow = 2^N, ncol = N)
matrix(rep(0,N*2^N),nrow = 2^N, ncol = N)
as.matrix(dat[nrow(dat),2:(N+1)])
kk = as.matrix(dat[nrow(dat),2:(N+1)])
class(kk)
SSMatrix[i,] <- as.matrix(dat[nrow(dat),2:(N+1)])
kk = SSMatrix[i,] <- as.matrix(dat[nrow(dat),2:(N+1)])
kk= as.matrix(dat[nrow(dat),2:(N+1)])
kk
SSMatrix[1,] = kk
SSMatrix <- matrix(NA,nrow = 2^N, ncol = N)
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- as.matrix(dat[nrow(dat),2:(N+1)])
}
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- matrix(NA,nrow = 2^N, ncol = N)
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- as.matrix(dat[nrow(dat),2:(N+1)])
}
i
i = 1
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- matrix(NA,nrow = 2^N, ncol = N)
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
dat
SSMatrix[1,]
SSMatrix[1,]
coln <- x(1:10)
coln <- c(1:10)
coln
SSMatrix <- as.data.frame(matrix(nrow = 2^N, ncol = N))
colnm <- c(1:10)
colnames(SSMatrix) <- colnm
head(SSMatrix)
dat[nrow(dat),2:(N+1)]
SSMatrix[1,] <- dat[nrow(dat),2:(N+1)]
head(SSMatrix)
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*(c0%*%x)+x*((ck1%*%x)%*%(ck2%*%x))
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
N <- 10
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Uncomment to execute the following section
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- as.data.frame(matrix(nrow = 2^N, ncol = N))
colnm <- c(1:10)
colnames(SSMatrix) <- colnm
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
}
head(SSMatrix)
tail(SSMatrix)
tail(mask)
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*(c0%*%x)+x*((ck1%*%x)%*%(ck2%*%x))
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
N <- 10
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- as.data.frame(matrix(nrow = 2^N, ncol = N))
colnm <- c(1:30)
colnames(SSMatrix) <- colnm
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
}
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*(c0%*%x)+x*((ck1%*%x)%*%(ck2%*%x))
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
N <- 10
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck1 <- sample(c(1),N,replace = TRUE)
ck2 <- runif(N, min = -1, max = 0.5)
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:10, init.x, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance')
###############################################################################
#Generate 2^N communities where species in each community (max possible N) are present or absent
###############################################################################
#Generate boolean mask of 2^N x N matrix
repeatBinaryNTimes <- rep(list(c(0,1)),N)
mask <- expand.grid(repeatBinaryNTimes)
#Loop through 2^N to apply each row in mask to initial abundance, solve ode, and retrieve final abundance
SSMatrix <- as.data.frame(matrix(nrow = 2^N, ncol = N))
colnm <- c(1:30)
colnames(SSMatrix) <- colnm
for (i in 1:2^N) {
init <- init.x*mask[i,]
init <- as.numeric(init)
dat <- n.integrate(0:10, init, glv, list(alpha=alpha, c0=c0, ck1 = ck1, ck2 = ck2))
SSMatrix[i,] <- dat[nrow(dat),2:(N+1)]
}
dat
tail(SSMatrix)
