for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
plot(differenceScoreVsSampleSize[,2],differenceScoreVsSampleSize[,1], main = 'Difference btw Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference btw Predicted and Actual')
write.table(differenceScoreVsSampleSize, paste(getwd(),'/lr3.csv', sep = ''), sep="\t")
library(plyr)
source('ML_GetCommunityParam.R')
source('ML_CommunitySimulation.R')
source('ML_FindSSDensity.R')
source('ML_PredictionAccuracy.R')
source('ML_GetBinaryInitialState.R')
#Number of of species
N = 10
##############################
#1. Get simulation parameters: alpha, c0, l, init
#Apply binary mask to init and loop:
#2. Simulation
#3. Find Steady State Density
#1. Get simulation parameters
simulationParam <- getCommunityParam(N)
alpha <- simulationParam$alpha
c0 <- simulationParam$c0
l <- simulationParam$l
init <- simulationParam$init
#mask as presence/absence of each species
mask <- getBinaryInitialState(N, 2^N)
#mask1 = mask$mask1 #for training
#mask2 = mask$mask2 #for testing
init_mask = t(t(mask) * init)
#init_mask_2 = t(t(mask2) * init)
#2. Do simulation and save result to dat_list
dat_list <- apply(init_mask, 1, function(x){growthFunction(N,alpha,c0,l,x)})
#3. Find steady state
matrixToSS <- function(densityMatrix){
s <- apply(densityMatrix[,2:(N+1)], MARGIN = 2, findSSDensity)
return(s)
}
#output list: each member is SS density of every species
SS <- lapply(dat_list, matrixToSS)
#rbind all members in the list to form matrix
SS <- do.call(rbind, SS)
#If SS density is too small, set to 0
SS[which(SS < 0.001)] = 0
########    consider modulate prediction part  ##########
init_mask_df = as.data.frame(init_mask)
SS_df = as.data.frame(SS)
#Of the input and output, those do not reach SS (contains NA in output) should be removed
if (any(is.na(SS_df))) {
#Row index where the row contains NA
NA_containing_rows = unique(which(is.na(SS_df),arr.ind = TRUE)[,1])
#Remove NA containing rows
init_mask_df = init_mask_df[-NA_containing_rows,]
SS_df = SS_df[-NA_containing_rows,]
}
CommunityDensity = as.matrix(apply(SS_df,1,sum))
colnames(CommunityDensity) = c('CommunityDensity')
all_data = init_mask_df
all_data$CommunityDensity = CommunityDensity
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
re = list(difference_score=difference_score,actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 2)
colnames(differenceScoreVsSampleSize) = c('difference_score','sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
plot(differenceScoreVsSampleSize[,2],differenceScoreVsSampleSize[,1], main = 'Difference btw Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference btw Predicted and Actual')
write.table(differenceScoreVsSampleSize, paste(getwd(),'/lr4.csv', sep = ''), sep="\t")
lr1 = read.csv('C:\\Source\\Microbiome\\lr1.csv',sep = '\t')
lr2 = read.csv('C:\\Source\\Microbiome\\lr2.csv',sep = '\t')
lr3 = read.csv('C:\\Source\\Microbiome\\lr3.csv',sep = '\t')
lr4 = read.csv('C:\\Source\\Microbiome\\lr4.csv',sep = '\t')
lr5 = read.csv('C:\\Source\\Microbiome\\lr5.csv',sep = '\t')
lr1
lr = rbind(lr1,lr2,lr3,lr4,lr5)
tail(lr)
18*5
lr
boxplot(difference_score~sample_size,data = lr)
par(mfrow = c(1,1))
boxplot(difference_score~sample_size,data = lr)
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual')
axis(side=2, at=c(0:0.05:2))
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual')
c(0:0.05:2)
seq(0:10:2)
seq(0:0.05:2)
?seq
seq(0,2,by = 0.05)
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual')
axis(side = 2, at = seq(0,2,by0.05))
axis(side = 2, at = seq(0,2,by=0.05))
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual',axis(side = 2, at = seq(0,2,by=0.05)))
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual', axes = offset())
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual', axes = FALSE)
axis(side = 2, at = seq(0,2,by=0.05))
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual', axes = FALSE)
axis(side = 2, at = seq(0,2,by=0.1))
lr$sample_size[:18]
lr$sample_size[1:18]
lr$sample_size[1:19]
axis(side = 1, at = lr$sample_size[1:18])
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual', axes = FALSE)
boxplot(difference_score~sample_size,data = lr, main = 'Density Difference btw Prediction(LR) and Actual', xlab = 'Training Sample Size', ylab = 'Difference btw Prediction and Actual', yaxt ='n')
axis(side = 2, at = seq(0,2,by=0.1))
library(plyr)
source('ML_GetCommunityParam.R')
source('ML_CommunitySimulation.R')
source('ML_FindSSDensity.R')
source('ML_PredictionAccuracy.R')
source('ML_GetBinaryInitialState.R')
head(all_data)
unique(c(1,2,3))
count(unique(c(1,2,3)))
nrow(unique(c(1,2,3)))
length(unique(1,2,3))
length(unique(c(1,2,3)))
length(unique(all_data$CommunityDensity))
length(all_data$CommunityDensity)
all_data$CommunityDensity[2]
all_data$CommunityDensity[4]
all_data$CommunityDensity[4] == all_data$CommunityDensity[2]
all_data$CommunityDensity[4]/all_data$CommunityDensity[2]
doi = all_data$CommunityDensity
plot(doi)
head(doi)
nrow(doi)
row.names(doi) = 1:1022
head(doi)
plot(doi)
plot(head(doi))
which(doi>1.8)
doi[which(doi>1.8)]
unique(doi[which(doi>1.8)])
1.981757==1.981757
head(doi)
doi[2]
doi[4]
doi[2] == doi4[]
doi[2] == doi[4]
all.equal(doi[2],doi[4])
?round
?round
round(doi[2]. 6)
round(doi[2], 6)
round(doi[2], 6) == round(doi[4],6)
round(c(1.26584597,2.65984366))
round(c(1.26584597,2.65984366),6)
doi = round(doi,6)
head(doi)
length(unique(doi))
doi = round(doi,3)
head(doi)
length(unique(doi))
library(plyr)
source('ML_GetCommunityParam.R')
source('ML_CommunitySimulation.R')
source('ML_FindSSDensity.R')
source('ML_PredictionAccuracy.R')
source('ML_GetBinaryInitialState.R')
#Number of of species
N = 10
##############################
#1. Get simulation parameters: alpha, c0, l, init
#Apply binary mask to init and loop:
#2. Simulation
#3. Find Steady State Density
#1. Get simulation parameters
simulationParam <- getCommunityParam(N)
alpha <- simulationParam$alpha
c0 <- simulationParam$c0
l <- simulationParam$l
init <- simulationParam$init
#mask as presence/absence of each species
mask <- getBinaryInitialState(N, 2^N)
#mask1 = mask$mask1 #for training
#mask2 = mask$mask2 #for testing
init_mask = t(t(mask) * init)
#init_mask_2 = t(t(mask2) * init)
#2. Do simulation and save result to dat_list
dat_list <- apply(init_mask, 1, function(x){growthFunction(N,alpha,c0,l,x)})
#3. Find steady state
matrixToSS <- function(densityMatrix){
s <- apply(densityMatrix[,2:(N+1)], MARGIN = 2, findSSDensity)
return(s)
}
#output list: each member is SS density of every species
SS <- lapply(dat_list, matrixToSS)
#rbind all members in the list to form matrix
SS <- do.call(rbind, SS)
#If SS density is too small, set to 0
SS[which(SS < 0.001)] = 0
########    consider modulate prediction part  ##########
init_mask_df = as.data.frame(init_mask)
SS_df = as.data.frame(SS)
#Of the input and output, those do not reach SS (contains NA in output) should be removed
if (any(is.na(SS_df))) {
#Row index where the row contains NA
NA_containing_rows = unique(which(is.na(SS_df),arr.ind = TRUE)[,1])
#Remove NA containing rows
init_mask_df = init_mask_df[-NA_containing_rows,]
SS_df = SS_df[-NA_containing_rows,]
}
CommunityDensity = as.matrix(apply(SS_df,1,sum))
colnames(CommunityDensity) = c('CommunityDensity')
all_data = init_mask_df
all_data$CommunityDensity = CommunityDensity
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
re = list(difference_score=difference_score,actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 2)
colnames(differenceScoreVsSampleSize) = c('difference_score','sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
plot(differenceScoreVsSampleSize[,2],differenceScoreVsSampleSize[,1], main = 'Difference btw Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference btw Predicted and Actual')
write.table(differenceScoreVsSampleSize, paste(getwd(),'/lr4.csv', sep = ''), sep="\t")
doi = all_data$CommunityDensity
head(doi)
length(unique(round(doi,3)))
all_data$CommunityDensity = round(all_data$CommunityDensity,3)
head(all_data)
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
re = list(difference_score=difference_score,actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 2)
colnames(differenceScoreVsSampleSize) = c('difference_score','sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
plot(differenceScoreVsSampleSize[,2],differenceScoreVsSampleSize[,1], main = 'Difference btw Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference btw Predicted and Actual')
write.table(differenceScoreVsSampleSize, paste(getwd(),'/lr4.csv', sep = ''), sep="\t")
length(unique(all_data$CommunityDensity))
#output list: each member is SS density of every species
SS <- lapply(dat_list, matrixToSS)
#rbind all members in the list to form matrix
SS <- do.call(rbind, SS)
#If SS density is too small, set to 0
SS[which(SS < 0.001)] = 0
init_mask_df = as.data.frame(init_mask)
SS_df = as.data.frame(SS)
if (any(is.na(SS_df))) {
#Row index where the row contains NA
NA_containing_rows = unique(which(is.na(SS_df),arr.ind = TRUE)[,1])
#Remove NA containing rows
init_mask_df = init_mask_df[-NA_containing_rows,]
SS_df = SS_df[-NA_containing_rows,]
}
CommunityDensity = as.matrix(apply(SS_df,1,sum))
colnames(CommunityDensity) = c('CommunityDensity')
all_data = init_mask_df
all_data$CommunityDensity = CommunityDensity
head(all_data)
length(unique(all_data$CommunityDensity))
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
rf = randomForest(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use rf to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(rf,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
re = list(difference_score=difference_score,actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 2)
colnames(differenceScoreVsSampleSize) = c('difference_score','sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
plot(differenceScoreVsSampleSize[,2],differenceScoreVsSampleSize[,1], main = 'Difference btw Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference btw Predicted and Actual')
library(randomForest)
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
rf = randomForest(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use rf to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(rf,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
re = list(difference_score=difference_score,actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 2)
colnames(differenceScoreVsSampleSize) = c('difference_score','sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
plot(differenceScoreVsSampleSize[,2],differenceScoreVsSampleSize[,1], main = 'Difference btw Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference btw Predicted and Actual')
write.table(differenceScoreVsSampleSize, paste(getwd(),'/score10.csv', sep = ''), sep="\t")
all_data$CommunityDensity = round(all_data$CommunityDensity,5)
length(unique(all_data$CommunityDensity))
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
rf = randomForest(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use rf to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(rf,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
re = list(difference_score=difference_score,actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 2)
colnames(differenceScoreVsSampleSize) = c('difference_score','sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
plot(differenceScoreVsSampleSize[,2],differenceScoreVsSampleSize[,1], main = 'Difference btw Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference btw Predicted and Actual')
write.table(differenceScoreVsSampleSize, paste(getwd(),'/score102.csv', sep = ''), sep="\t")
