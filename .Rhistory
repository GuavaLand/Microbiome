#Save all the returned matrices
difference_score = returned$difference_score
prediction_accuracy_mean = returned$prediction_accuracy_mean
prediction_accuracy_sd = returned$prediction_accuracy_sd
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = prediction_accuracy_mean
differenceScoreVsSampleSize[row_counter,3] = prediction_accuracy_sd
differenceScoreVsSampleSize[row_counter,4] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
#Plot our defined difference score as a function of training sample size
plot(differenceScoreVsSampleSize[,4],differenceScoreVsSampleSize[,1], main = 'LR Difference Score of Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference Score of Predicted and Actual')
#Plot our accuracy measure as a function of training sample size (scatter plot with error bar)
differenceScoreVsSampleSize = as.data.frame(differenceScoreVsSampleSize)
p <- ggplot(differenceScoreVsSampleSize, aes(x=sample_size, y=prediction_accuracy_mean)) +
geom_line()+
geom_point()+
geom_errorbar(aes(ymin=prediction_accuracy_mean-prediction_accuracy_sd, ymax=prediction_accuracy_mean+prediction_accuracy_sd))
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.5,0.8,0.1))
#write.table(differenceScoreVsSampleSize, paste(getwd(),'/score102.csv', sep = ''), sep="\t")
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 150
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
#Another way of expressing accuracy: mean of prediction error%
prediction_accuracy_mean = mean(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
prediction_accuracy_sd = sd(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
re = list(difference_score=difference_score,
prediction_accuracy_mean=prediction_accuracy_mean,
prediction_accuracy_sd=prediction_accuracy_sd,
actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score and accuracy measure
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 4)
colnames(differenceScoreVsSampleSize) = c('difference_score',
'prediction_accuracy_mean',
'prediction_accuracy_sd',
'sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,80,10))) {
sample_size = counter *10
returned = model(sample_size)
#Save all the returned matrices
difference_score = returned$difference_score
prediction_accuracy_mean = returned$prediction_accuracy_mean
prediction_accuracy_sd = returned$prediction_accuracy_sd
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = prediction_accuracy_mean
differenceScoreVsSampleSize[row_counter,3] = prediction_accuracy_sd
differenceScoreVsSampleSize[row_counter,4] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
#Plot our defined difference score as a function of training sample size
plot(differenceScoreVsSampleSize[,4],differenceScoreVsSampleSize[,1], main = 'LR Difference Score of Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference Score of Predicted and Actual')
#Plot our accuracy measure as a function of training sample size (scatter plot with error bar)
differenceScoreVsSampleSize = as.data.frame(differenceScoreVsSampleSize)
p <- ggplot(differenceScoreVsSampleSize, aes(x=sample_size, y=prediction_accuracy_mean)) +
geom_line()+
geom_point()+
geom_errorbar(aes(ymin=prediction_accuracy_mean-prediction_accuracy_sd, ymax=prediction_accuracy_mean+prediction_accuracy_sd))
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.5,0.8,0.1))
#write.table(differenceScoreVsSampleSize, paste(getwd(),'/score102.csv', sep = ''), sep="\t")
differenceScoreVsSampleSize
warnings()
warnings()
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 150
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
#Another way of expressing accuracy: mean of prediction error%
prediction_accuracy_mean = mean(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
prediction_accuracy_sd = sd(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
re = list(difference_score=difference_score,
prediction_accuracy_mean=prediction_accuracy_mean,
prediction_accuracy_sd=prediction_accuracy_sd,
actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score and accuracy measure
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 4)
colnames(differenceScoreVsSampleSize) = c('difference_score',
'prediction_accuracy_mean',
'prediction_accuracy_sd',
'sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,80,10))) {
sample_size = counter *10
returned = model(sample_size)
#Save all the returned matrices
difference_score = returned$difference_score
prediction_accuracy_mean = returned$prediction_accuracy_mean
prediction_accuracy_sd = returned$prediction_accuracy_sd
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = prediction_accuracy_mean
differenceScoreVsSampleSize[row_counter,3] = prediction_accuracy_sd
differenceScoreVsSampleSize[row_counter,4] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
warnings()
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 200
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
#Another way of expressing accuracy: mean of prediction error%
prediction_accuracy_mean = mean(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
prediction_accuracy_sd = sd(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
re = list(difference_score=difference_score,
prediction_accuracy_mean=prediction_accuracy_mean,
prediction_accuracy_sd=prediction_accuracy_sd,
actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score and accuracy measure
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 4)
colnames(differenceScoreVsSampleSize) = c('difference_score',
'prediction_accuracy_mean',
'prediction_accuracy_sd',
'sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,80,10))) {
sample_size = counter *10
returned = model(sample_size)
#Save all the returned matrices
difference_score = returned$difference_score
prediction_accuracy_mean = returned$prediction_accuracy_mean
prediction_accuracy_sd = returned$prediction_accuracy_sd
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = prediction_accuracy_mean
differenceScoreVsSampleSize[row_counter,3] = prediction_accuracy_sd
differenceScoreVsSampleSize[row_counter,4] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
warnings()
#Plot our defined difference score as a function of training sample size
plot(differenceScoreVsSampleSize[,4],differenceScoreVsSampleSize[,1], main = 'LR Difference Score of Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference Score of Predicted and Actual')
differenceScoreVsSampleSize
predicted_SS
actual_sample$CommunityDensity
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 500
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
#Another way of expressing accuracy: mean of prediction error%
prediction_accuracy_mean = mean(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
prediction_accuracy_sd = sd(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
re = list(difference_score=difference_score,
prediction_accuracy_mean=prediction_accuracy_mean,
prediction_accuracy_sd=prediction_accuracy_sd,
actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score and accuracy measure
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 4)
colnames(differenceScoreVsSampleSize) = c('difference_score',
'prediction_accuracy_mean',
'prediction_accuracy_sd',
'sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,80,10))) {
sample_size = counter *10
returned = model(sample_size)
#Save all the returned matrices
difference_score = returned$difference_score
prediction_accuracy_mean = returned$prediction_accuracy_mean
prediction_accuracy_sd = returned$prediction_accuracy_sd
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = prediction_accuracy_mean
differenceScoreVsSampleSize[row_counter,3] = prediction_accuracy_sd
differenceScoreVsSampleSize[row_counter,4] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
#Plot our defined difference score as a function of training sample size
plot(differenceScoreVsSampleSize[,4],differenceScoreVsSampleSize[,1], main = 'LR Difference Score of Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference Score of Predicted and Actual')
#Plot our accuracy measure as a function of training sample size (scatter plot with error bar)
differenceScoreVsSampleSize = as.data.frame(differenceScoreVsSampleSize)
p <- ggplot(differenceScoreVsSampleSize, aes(x=sample_size, y=prediction_accuracy_mean)) +
geom_line()+
geom_point()+
geom_errorbar(aes(ymin=prediction_accuracy_mean-prediction_accuracy_sd, ymax=prediction_accuracy_mean+prediction_accuracy_sd))
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.5,0.8,0.1))
#write.table(differenceScoreVsSampleSize, paste(getwd(),'/score102.csv', sep = ''), sep="\t")
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
#Another way of expressing accuracy: mean of prediction error%
prediction_accuracy_mean = mean(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
prediction_accuracy_sd = sd(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
re = list(difference_score=difference_score,
prediction_accuracy_mean=prediction_accuracy_mean,
prediction_accuracy_sd=prediction_accuracy_sd,
actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score and accuracy measure
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 4)
colnames(differenceScoreVsSampleSize) = c('difference_score',
'prediction_accuracy_mean',
'prediction_accuracy_sd',
'sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,80,10))) {
sample_size = counter *10
returned = model(sample_size)
#Save all the returned matrices
difference_score = returned$difference_score
prediction_accuracy_mean = returned$prediction_accuracy_mean
prediction_accuracy_sd = returned$prediction_accuracy_sd
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = prediction_accuracy_mean
differenceScoreVsSampleSize[row_counter,3] = prediction_accuracy_sd
differenceScoreVsSampleSize[row_counter,4] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
#Plot our defined difference score as a function of training sample size
plot(differenceScoreVsSampleSize[,4],differenceScoreVsSampleSize[,1], main = 'LR Difference Score of Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference Score of Predicted and Actual')
#Plot our accuracy measure as a function of training sample size (scatter plot with error bar)
differenceScoreVsSampleSize = as.data.frame(differenceScoreVsSampleSize)
p <- ggplot(differenceScoreVsSampleSize, aes(x=sample_size, y=prediction_accuracy_mean)) +
geom_line()+
geom_point()+
geom_errorbar(aes(ymin=prediction_accuracy_mean-prediction_accuracy_sd, ymax=prediction_accuracy_mean+prediction_accuracy_sd))
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.5,0.8,0.1))
#write.table(differenceScoreVsSampleSize, paste(getwd(),'/score102.csv', sep = ''), sep="\t")
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.3,0.8,0.1))
differenceScoreVsSampleSize = as.data.frame(differenceScoreVsSampleSize)
p <- ggplot(differenceScoreVsSampleSize, aes(x=sample_size, y=prediction_accuracy_mean)) +
geom_line()+
geom_point()+
geom_errorbar(aes(ymin=prediction_accuracy_mean-prediction_accuracy_sd, ymax=prediction_accuracy_mean+prediction_accuracy_sd))
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.3,0.8,0.1))
#write.table(differenceScoreVsSampleSize, paste(getwd(),'/score102.csv', sep = ''), sep="\t")
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.5,0.8,0.1))
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.5,0.8,0.1),limits=c(-0.3,0.8))
warnings()
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
#Another way of expressing accuracy: mean of prediction error%
prediction_accuracy_mean = mean(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
prediction_accuracy_sd = sd(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
re = list(difference_score=difference_score,
prediction_accuracy_mean=prediction_accuracy_mean,
prediction_accuracy_sd=prediction_accuracy_sd,
actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score and accuracy measure
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 4)
colnames(differenceScoreVsSampleSize) = c('difference_score',
'prediction_accuracy_mean',
'prediction_accuracy_sd',
'sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,80,10))) {
sample_size = counter *10
returned = model(sample_size)
#Save all the returned matrices
difference_score = returned$difference_score
prediction_accuracy_mean = returned$prediction_accuracy_mean
prediction_accuracy_sd = returned$prediction_accuracy_sd
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = prediction_accuracy_mean
differenceScoreVsSampleSize[row_counter,3] = prediction_accuracy_sd
differenceScoreVsSampleSize[row_counter,4] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
#Plot our defined difference score as a function of training sample size
plot(differenceScoreVsSampleSize[,4],differenceScoreVsSampleSize[,1], main = 'LR Difference Score of Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference Score of Predicted and Actual')
#Plot our accuracy measure as a function of training sample size (scatter plot with error bar)
differenceScoreVsSampleSize = as.data.frame(differenceScoreVsSampleSize)
p <- ggplot(differenceScoreVsSampleSize, aes(x=sample_size, y=prediction_accuracy_mean)) +
geom_line()+
geom_point()+
geom_errorbar(aes(ymin=prediction_accuracy_mean-prediction_accuracy_sd, ymax=prediction_accuracy_mean+prediction_accuracy_sd))
#title, labels etc.
p+labs(title="LR Prediction Accuracy as % Difference btw Predicted and Actual", x="Training Sample Size", y = "Mean of Prediction Error%")+
scale_y_continuous(breaks=seq(-0.5,0.8,0.1),limits=c(-0.3,0.8))
#write.table(differenceScoreVsSampleSize, paste(getwd(),'/score102.csv', sep = ''), sep="\t")
warnings()
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
#Another way of expressing accuracy: mean of prediction error%
prediction_accuracy_mean = mean(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
prediction_accuracy_sd = sd(abs(predicted_SS - actual_sample$CommunityDensity)/actual_sample$CommunityDensity)
re = list(difference_score=difference_score,
prediction_accuracy_mean=prediction_accuracy_mean,
prediction_accuracy_sd=prediction_accuracy_sd,
actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 4)
colnames(differenceScoreVsSampleSize) = c('difference_score',
'prediction_accuracy_mean',
'prediction_accuracy_sd',
'sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,80,10))) {
sample_size = counter *10
returned = model(sample_size)
#Save all the returned matrices
difference_score = returned$difference_score
prediction_accuracy_mean = returned$prediction_accuracy_mean
prediction_accuracy_sd = returned$prediction_accuracy_sd
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = prediction_accuracy_mean
differenceScoreVsSampleSize[row_counter,3] = prediction_accuracy_sd
differenceScoreVsSampleSize[row_counter,4] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
#Plot our defined difference score as a function of training sample size
plot(differenceScoreVsSampleSize[,4],differenceScoreVsSampleSize[,1], main = 'LR Difference Score of Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference Score of Predicted and Actual')
warnings()
