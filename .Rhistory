HOINA <- any(is.na(HOI[i,]))
GLVNA <- any(is.na(GLV[i,]))
#If there is NA in a particular row, for wither HOI or GLV, this community combination did not reach SS within integration time. Move to next row
if (!HOINA & !GLVNA) {
#If no NA in both HOI and GLV (for that row, both model reached steady state)
CommunitySteadyStateTime[i,1] <- n * 5
CommunitySteadyStateTime[i,2] <- max(HOI[i,2:ncol(HOI)])
CommunitySteadyStateTime[i,3] <- max(GLV[i,2:ncol(GLV)])
}
else{
CommunitySteadyStateTime[i,1] <- n * 5
CommunitySteadyStateTime[i,2] <- NA
CommunitySteadyStateTime[i,3] <- NA
}
}
#Finished looping through an HOI_SSN and GLV_SSN, store the CommunitySteadyStateTime vector to a list
CommunitySteadyStateDF <-  rbind(CommunitySteadyStateDF,as.data.frame(CommunitySteadyStateTime))
}
#Calculate the difference of community SS time between GLV model and and HOI model
CommunitySteadyStateDF$Difference <- CommunitySteadyStateDF$SteadyStateTimeGLV - CommunitySteadyStateDF$SteadyStateTimeHOI
#plot
par(mfrow = c(3,2))
#plot histogram for Community Steady State time difference for each of the community size
for (n in 1:length(HOI_list)) {
hist(CommunitySteadyStateDF[CommunitySteadyStateDF$CommunitySize == n*5,4], main = paste('How Much Longer Does GLV Reaches SS Than HOI',n*5,'Species'), xlab = 'Time Difference', ylim = c(0,500), breaks = 18)
}
boxplot(Difference~CommunitySize ,data = CommunitySteadyStateDF, main = 'How Much Longer Does GLV Reaches SS Than HOI', xlab = 'Community Size', ylab = 'Time Difference')
head(CommunitySteadyStateDF)
tail(CommunitySteadyStateDF)
CommunitySteadyStateDF[190:200,]
tail(HOI)
tail(GLV)
library(deSolve)
#Define GLV with varying coefficient
glv <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*as.vector(c0%*%x)+x*t(t(x)%*%(do.call(cbind, lapply(l, FUN=function(ma) ma%*%x))))
list(dx)
})
}
#glv1 as original GLV
#c0 is beta
glv1 <- function(t, x, params){
with(as.list(params, c(x)),{
dx <- alpha*x + x*as.vector(c0%*%x)
list(dx)
})
}
#Define integration method
n.integrate <- function(time, init.x, model, params){
as.data.frame(lsoda(init.x, time, model, params))
}
#Define community size
#N <- 30
growthFunction <- function(N){
#Define species intrinsic growth rate
alpha <- runif(N)
#Define the constant in species-species interation coefficient
c0 <- matrix(runif(N*N, min = -1, max = 0),nrow = N)
#Set species self interation to -0.5
for (i in 1:N) {
for (j in 1:N) {
if (i == j) {
c0[i,j] <-  -0.5
}
}
}
#Define coefficient of linear term in species-species interation coefficient
ck <- runif(N*N, min = -1, max = 0.2)
ck <- matrix(ck, nrow = N)
l <- list()
for (i in 1:N) {
#For i-th matrix, i-th row is 0
temp <- ck
temp[i,] <- 0
#In i-th matrix, elements are 0 if k (column) == either j (row) or i (matrix order)
for (j in 1:N) {
for (k in 1:N) {
if (k==j | k == i) {
temp[j,k] <- 0
}
}
}
#Control the prevalence of thrid party effects
#for (element in 1:length(temp)) {
#  dice <- runif(1)
#  if (dice > -1) { #what percent of to assign 0
#    temp[element] <- 0
#  }
#}
l[[i]] <- temp
}
#Define initial abundance between 0.1 and 1, to 1 decimal place
init.x <- floor(runif(N, min = 1, max = 10))/10
#Solve the ode
dat <- n.integrate(0:500, init.x, glv, list(alpha=alpha, c0=c0, l=l))
dat1 <- n.integrate(0:500, init.x, glv1, list(alpha=alpha, c0=c0))
#Plot
matplot(x=dat$time, y=dat[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Modified GLV-density', N,'species'))
matplot(x=dat1$time, y=dat1[,-1], typ='b', xlab='time', ylab='Absolute abundance', main=paste('Original GLV-density', N,'species'))
returnList <- list(dat,dat1)
return(returnList)
}
######################################################################################
#Given density data (vector) over time (1:length(vector)), find steady state time
#If there is no steady state, return NaN
######################################################################################
FindSS <- function(vec){
for (i in 1:(length(vec) - 10)) {
#From start, search for 3 points each 5 unit time apart where delta < 10^-3
thisSlope <- abs(vec[i+1] - vec[i])
nextSlope <- abs((vec[i+5] - vec[i])/5)
lastSlope <- abs(vec[i+10] - vec[i+9])
if (thisSlope < 10^-3 & nextSlope < 10^-3 & lastSlope < 10^-3) {
#Verification: make sure no change after plateau: extrapolate
#Extrapolate by thisSlope and calculate value at end of integration time
ExtrEndTimeValue = vec[i] + nextSlope*(length(vec) - i)
if ((ExtrEndTimeValue < (vec[length(vec)]) + 0.01)& (ExtrEndTimeValue > (vec[length(vec)]) - 0.01)) {
return(i)
}
#There is a plateau in the middle, but in the end density changes again: find next plateau and verify agin
}
}
#Til the end no steady state found
return(NaN)
}
###############################################################
#Simulate species growth function given number of species N
#Find the steady state for each species and store in matrix HOI_SSN or GLV_SSN, based on model used for simulation
#Save HOI_SSN and GLV_SSN as csv at working directory
###############################################################
numTrial = 20
HOI_list <- list()
GLV_list <- list()
for (n in 1:3) {
#n is a counter. N is the number of species in community
N <- n*5
HOI_SSN <-  matrix(nrow = numTrial, ncol = N)
GLV_SSN <-  matrix(nrow = numTrial, ncol = N)
for (trial in 1:numTrial) {
repeat {
#densityData is a list of dat (HOI model) and dat1 (GLV)
densityData <- growthFunction(N)
#Check if any NaN in dat
dat <- densityData[[1]]
datNA <- any(is.na(dat))
#Check if any NaN in dat1
dat1 <- densityData[[2]]
dat1NA <- any(is.na(dat1))
#If any of datNA and dat1NA is true, growth function should run again
if(!(datNA|dat1NA)){
break
}
}
#Modified GLV
for (species in 2:ncol(dat)) {
HOI_SSN[trial,species-1] <-  FindSS(dat[,species])
}
#Original GLV
for (oSpecies in 2:ncol(dat1)) {
GLV_SSN[trial,oSpecies-1] <-  FindSS(dat1[,oSpecies])
}
}
HOI_list[[n]] <- HOI_SSN
GLV_list[[n]] <- GLV_SSN
}
###########################################################
#Find community steady state time and plot histogram
###########################################################
CommunitySteadyStateDF <- data.frame()
#Loop through HOI_SS10, HOI_SS20...GLV_SS10, GLV_SS20...
for (n in 1:length(HOI_list)) {
HOI = HOI_list[[n]]
GLV = GLV_list[[n]]
numOfEntries = nrow(HOI)
#CommunitySteadyStateTime to store the time when the whole community has reached steady state
CommunitySteadyStateTime <- matrix(nrow = numOfEntries, ncol = 3)
colnames(CommunitySteadyStateTime) <- c('CommunitySize', 'SteadyStateTimeHOI', 'SteadyStateTimeGLV')
for (i in 1:numOfEntries) {
HOINA <- any(is.na(HOI[i,]))
GLVNA <- any(is.na(GLV[i,]))
#If there is NA in a particular row, for wither HOI or GLV, this community combination did not reach SS within integration time. Move to next row
if (!HOINA & !GLVNA) {
#If no NA in both HOI and GLV (for that row, both model reached steady state)
CommunitySteadyStateTime[i,1] <- n * 5
CommunitySteadyStateTime[i,2] <- max(HOI[i,1:ncol(HOI)])
CommunitySteadyStateTime[i,3] <- max(GLV[i,1:ncol(GLV)])
}
else{
CommunitySteadyStateTime[i,1] <- n * 5
CommunitySteadyStateTime[i,2] <- NA
CommunitySteadyStateTime[i,3] <- NA
}
}
#Finished looping through an HOI_SSN and GLV_SSN, store the CommunitySteadyStateTime vector to a list
CommunitySteadyStateDF <-  rbind(CommunitySteadyStateDF,as.data.frame(CommunitySteadyStateTime))
}
#Calculate the difference of community SS time between GLV model and and HOI model
CommunitySteadyStateDF$Difference <- CommunitySteadyStateDF$SteadyStateTimeGLV - CommunitySteadyStateDF$SteadyStateTimeHOI
#plot
par(mfrow = c(3,2))
#plot histogram for Community Steady State time difference for each of the community size
for (n in 1:length(HOI_list)) {
hist(CommunitySteadyStateDF[CommunitySteadyStateDF$CommunitySize == n*5,4], main = paste('How Much Longer Does GLV Reaches SS Than HOI',n*5,'Species'), xlab = 'Time Difference', ylim = c(0,500), breaks = 18)
}
boxplot(Difference~CommunitySize ,data = CommunitySteadyStateDF, main = 'How Much Longer Does GLV Reaches SS Than HOI', xlab = 'Community Size', ylab = 'Time Difference')
GLV[10:20,]
nrow(CommunitySteadyStateDF)
CommunitySteadyStateDF[50:60,]
CommunitySteadyStateDF[30:60,]
x = seq(0,1,0.1)
x
y = -(1-x)*log(1-x) - x*logx
y = -(1-x)*log(1-x) - x*log(x)
plot(x,y)
k1 = read.csv('C:\\Source\\Microbiome\\score10.csv',sep = '\t')
k = read.csv('C:\\Source\\Microbiome\\score101.csv',sep = '\t')
k2 = read.csv('C:\\Source\\Microbiome\\score102.csv',sep = '\t')
k3 = read.csv('C:\\Source\\Microbiome\\score103.csv',sep = '\t')
k4 = read.csv('C:\\Source\\Microbiome\\score104.csv',sep = '\t')
k5 = read.csv('C:\\Source\\Microbiome\\score105.csv',sep = '\t')
setwd(C:\Users\yin\source\Microbiome)
setwd(C:\\Users\\yin\\source\\Microbiome)
setwd('C:\\Users\\yin\\source\\Microbiome')
k1 = read.csv('score10.csv',sep = '\t')
k = read.csv('score101.csv',sep = '\t')
k2 = read.csv('score102.csv',sep = '\t')
k3 = read.csv('score103.csv',sep = '\t')
k4 = read.csv('score104.csv',sep = '\t')
k5 = read.csv('score105.csv',sep = '\t')
head(k1)
rbind(k,k1,k2,k3,k4,k5)
boxplot(difference_score~sample_size ,data = dat, main = 'How Much Longer Does GLV Reaches SS Than HOI', xlab = 'Community Size', ylab = 'Time Difference')
dat = rbind(k,k1,k2,k3,k4,k5)
boxplot(difference_score~sample_size ,data = dat, main = 'How Much Longer Does GLV Reaches SS Than HOI', xlab = 'Community Size', ylab = 'Time Difference')
boxplot(difference_score~sample_size ,data = dat, main = 'Density Difference btw Actual and Prediction', xlab = 'Training Sample Size', ylab = 'Difference')
boxplot(difference_score~sample_size ,data = dat, main = 'Density Difference btw Prediction and Actual', xlab = 'Training Sample Size', ylab = 'Difference')
boxplot(difference_score~sample_size ,data = dat, main = 'Density Difference btw Prediction and Actual', xlab = 'Training Sample Size', ylab = 'Squared Difference')
library(plyr)
library(randomForest)
source('ML_GetCommunityParam.R')
source('ML_CommunitySimulation.R')
source('ML_FindSSDensity.R')
source('ML_PredictionAccuracy.R')
source('ML_GetBinaryInitialState.R')
#Number of of species
N = 10
#1. Get simulation parameters
simulationParam <- getCommunityParam(N)
alpha <- simulationParam$alpha
c0 <- simulationParam$c0
l <- simulationParam$l
init <- simulationParam$init
#mask as presence/absence of each species
mask <- getBinaryInitialState(N, 2^N)
init_mask = t(t(mask) * init)
head(init_mask)
init
head(mask)
#2. Do simulation and save result to dat_list
dat_list <- apply(init_mask, 1, function(x){growthFunction(N,alpha,c0,l,x)})
head(dat_list)
#3. Find steady state
matrixToSS <- function(densityMatrix){
s <- apply(densityMatrix[,2:(N+1)], MARGIN = 2, findSSDensity)
return(s)
}
#output list: each member is SS density of every species
SS <- lapply(dat_list, matrixToSS)
#rbind all members in the list to form matrix
SS <- do.call(rbind, SS)
#If SS density is too small, set to 0
SS[which(SS < 0.001)] = 0
head(SS)
head(init_mask)
init_mask_df = as.data.frame(init_mask)
SS_df = as.data.frame(SS)
any(is.na(SS_df))
tail(SS_df)
if (any(is.na(SS_df))) {
#Row index where the row contains NA
NA_containing_rows = unique(which(is.na(SS_df),arr.ind = TRUE)[,1])
#Remove NA containing rows
init_mask_df = init_mask_df[-NA_containing_rows,]
SS_df = SS_df[-NA_containing_rows,]
}
CommunityDensity = as.matrix(apply(SS_df,1,sum))
colnames(CommunityDensity) = c('CommunityDensity')
all_data = init_mask_df
all_data$CommunityDensity = CommunityDensity
head(all_data)
library(plyr)
source('ML_GetCommunityParam.R')
source('ML_CommunitySimulation.R')
source('ML_FindSSDensity.R')
source('ML_PredictionAccuracy.R')
source('ML_GetBinaryInitialState.R')
#Number of of species
N = 10
#1. Get simulation parameters
simulationParam <- getCommunityParam(N)
alpha <- simulationParam$alpha
c0 <- simulationParam$c0
l <- simulationParam$l
init <- simulationParam$init
#mask as presence/absence of each species
mask <- getBinaryInitialState(N, 2^N)
init_mask = t(t(mask) * init)
#2. Do simulation and save result to dat_list
dat_list <- apply(init_mask, 1, function(x){growthFunction(N,alpha,c0,l,x)})
#3. Find steady state
matrixToSS <- function(densityMatrix){
s <- apply(densityMatrix[,2:(N+1)], MARGIN = 2, findSSDensity)
return(s)
}
#3. Find steady state
matrixToSS <- function(densityMatrix){
s <- apply(densityMatrix[,2:(N+1)], MARGIN = 2, findSSDensity)
return(s)
}
#output list: each member is SS density of every species
SS <- lapply(dat_list, matrixToSS)
#rbind all members in the list to form matrix
SS <- do.call(rbind, SS)
#If SS density is too small, set to 0
SS[which(SS < 0.001)] = 0
init_mask_df = as.data.frame(init_mask)
SS_df = as.data.frame(SS)
if (any(is.na(SS_df))) {
#Row index where the row contains NA
NA_containing_rows = unique(which(is.na(SS_df),arr.ind = TRUE)[,1])
#Remove NA containing rows
init_mask_df = init_mask_df[-NA_containing_rows,]
SS_df = SS_df[-NA_containing_rows,]
}
CommunityDensity = as.matrix(apply(SS_df,1,sum))
colnames(CommunityDensity) = c('CommunityDensity')
all_data = init_mask_df
all_data$CommunityDensity = CommunityDensity
doi = all_data$CommunityDensity
max(doi)
min(doi)
plot(doi)
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
re = list(difference_score=difference_score,actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 2)
colnames(differenceScoreVsSampleSize) = c('difference_score','sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
library(plyr)
source('ML_GetCommunityParam.R')
source('ML_CommunitySimulation.R')
source('ML_FindSSDensity.R')
source('ML_PredictionAccuracy.R')
source('ML_GetBinaryInitialState.R')
#Number of of species
N = 10
##############################
#1. Get simulation parameters: alpha, c0, l, init
#Apply binary mask to init and loop:
#2. Simulation
#3. Find Steady State Density
#1. Get simulation parameters
simulationParam <- getCommunityParam(N)
alpha <- simulationParam$alpha
c0 <- simulationParam$c0
l <- simulationParam$l
init <- simulationParam$init
#mask as presence/absence of each species
mask <- getBinaryInitialState(N, 2^N)
#mask1 = mask$mask1 #for training
#mask2 = mask$mask2 #for testing
init_mask = t(t(mask) * init)
#init_mask_2 = t(t(mask2) * init)
#2. Do simulation and save result to dat_list
dat_list <- apply(init_mask, 1, function(x){growthFunction(N,alpha,c0,l,x)})
#3. Find steady state
matrixToSS <- function(densityMatrix){
s <- apply(densityMatrix[,2:(N+1)], MARGIN = 2, findSSDensity)
return(s)
}
#output list: each member is SS density of every species
SS <- lapply(dat_list, matrixToSS)
#rbind all members in the list to form matrix
SS <- do.call(rbind, SS)
#If SS density is too small, set to 0
SS[which(SS < 0.001)] = 0
########    consider modulate prediction part  ##########
init_mask_df = as.data.frame(init_mask)
SS_df = as.data.frame(SS)
#Of the input and output, those do not reach SS (contains NA in output) should be removed
if (any(is.na(SS_df))) {
#Row index where the row contains NA
NA_containing_rows = unique(which(is.na(SS_df),arr.ind = TRUE)[,1])
#Remove NA containing rows
init_mask_df = init_mask_df[-NA_containing_rows,]
SS_df = SS_df[-NA_containing_rows,]
}
CommunityDensity = as.matrix(apply(SS_df,1,sum))
colnames(CommunityDensity) = c('CommunityDensity')
all_data = init_mask_df
all_data$CommunityDensity = CommunityDensity
model <- function(train_size){ #make model training reusable with a single set of simulation (all_data)
#Decide how many sample to train model
train_size = train_size
train_data = all_data[1:train_size,]
lr = lm(CommunityDensity ~ ., data = train_data)
###########################################
#1. take test_sample_size samples from all data
#2. use lr to predict final state
#3. calculate prediction accuracy
#4. save as a csv to cwd
test_sample_size = 50
#1. take test sample
actual_sample  = all_data[(train_size+1):(train_size + test_sample_size),]
#2. use rf_species to predict final state
predicted_SS = matrix(nrow = nrow(actual_sample), ncol = 1)
colnames(predicted_SS) = c('Predicted_Community_Density')
for (row in 1:nrow(actual_sample)) {
data_point = as.data.frame(actual_sample[row,1:N])
predicted_SS[row,1] = predict(lr,data_point)
}
#3. calculate accuracy
difference_score = colSums((predicted_SS - actual_sample$CommunityDensity)^2)/nrow(actual_sample)
re = list(difference_score=difference_score,actual_sample=actual_sample,
predicted_SS=predicted_SS)
return(re)
}
#Create matrix to store training sample size and the result difference score
differenceScoreVsSampleSize = matrix(nrow = 18, ncol = 2)
colnames(differenceScoreVsSampleSize) = c('difference_score','sample_size')
par(mfrow = c(3,3))
row_counter = 0
for (counter in c(c(1:9),seq(10,90,10))) {
sample_size = counter *10
returned = model(sample_size)
difference_score = returned$difference_score
actual_sample = returned$actual_sample
predicted_SS = returned$predicted_SS
row_counter = row_counter + 1
differenceScoreVsSampleSize[row_counter,1] = difference_score
differenceScoreVsSampleSize[row_counter,2] = sample_size
plot(actual_sample$CommunityDensity,predicted_SS, main = paste(sample_size,'Samples Training:',round(difference_score,4)),
xlab = 'Actual Community Density',ylab = 'Predicted Community Density')
}
plot(differenceScoreVsSampleSize[,2],differenceScoreVsSampleSize[,1], main = 'Difference btw Predicted and Actual \nCommunity Density over Sample Size',
xlab = 'Training Sample Size', ylab = 'Difference btw Predicted and Actual')
#write.table(differenceScoreVsSampleSize, paste(getwd(),'/score10.csv', sep = ''), sep="\t")
library(plyr)
source('ML_GetCommunityParam.R')
source('ML_CommunitySimulation.R')
source('ML_FindSSDensity.R')
source('ML_PredictionAccuracy.R')
source('ML_GetBinaryInitialState.R')
#Number of of species
N = 10
##############################
#1. Get simulation parameters: alpha, c0, l, init
#Apply binary mask to init and loop:
#2. Simulation
#3. Find Steady State Density
#1. Get simulation parameters
simulationParam <- getCommunityParam(N)
alpha <- simulationParam$alpha
c0 <- simulationParam$c0
l <- simulationParam$l
init <- simulationParam$init
#mask as presence/absence of each species
mask <- getBinaryInitialState(N, 2^N)
#mask1 = mask$mask1 #for training
#mask2 = mask$mask2 #for testing
init_mask = t(t(mask) * init)
#init_mask_2 = t(t(mask2) * init)
#2. Do simulation and save result to dat_list
dat_list <- apply(init_mask, 1, function(x){growthFunction(N,alpha,c0,l,x)})
